name: Deploy Lambda to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch: # Permite execu√ß√£o manual

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY_NAME: ${{ secrets.ECR_REPOSITORY_NAME }}

jobs:
  build-and-push:
    name: Build and Push Docker Image to ECR
    runs-on: ubuntu-latest
    
    outputs:
      ecr_image_uri: ${{ steps.vars.outputs.ecr_image_uri }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2
        with:
          registries: ${{ secrets.AWS_ACCOUNT_ID }}

      - name: Set up variables
        id: vars
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
        run: |
          # Valida que AWS_ACCOUNT_ID est√° dispon√≠vel
          if [ -z "${AWS_ACCOUNT_ID}" ]; then
            echo "‚ùå Erro: AWS_ACCOUNT_ID n√£o est√° dispon√≠vel!"
            exit 1
          fi
          
          # Tenta obter o registry do output do login, se n√£o estiver dispon√≠vel, constr√≥i manualmente
          ECR_REGISTRY="${{ steps.login-ecr.outputs.registry }}"
          
          if [ -z "${ECR_REGISTRY}" ] || [[ ! "${ECR_REGISTRY}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚ö†Ô∏è Registry n√£o encontrado no output ou inv√°lido, construindo manualmente..."
            ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
            echo "‚úÖ Registry constru√≠do: ${ECR_REGISTRY}"
          else
            echo "‚úÖ Registry obtido do login: ${ECR_REGISTRY}"
          fi
          
          echo "üîç Debug - AWS_ACCOUNT_ID: ${AWS_ACCOUNT_ID}"
          echo "üîç Debug - AWS_REGION: ${AWS_REGION}"
          echo "üîç Debug - ECR_REGISTRY: ${ECR_REGISTRY}"
          echo "üîç Debug - ECR_REPOSITORY_NAME: ${ECR_REPOSITORY_NAME}"
          
          ECR_REPOSITORY_URL="${ECR_REGISTRY}/${ECR_REPOSITORY_NAME}"
          IMAGE_TAG="sha-${GITHUB_SHA::7}"
          ECR_IMAGE_URI="${ECR_REPOSITORY_URL}:${IMAGE_TAG}"
          
          # Valida que a URI est√° completa
          if [[ ! "${ECR_IMAGE_URI}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚ùå Erro: ECR_IMAGE_URI constru√≠da est√° inv√°lida: ${ECR_IMAGE_URI}"
            exit 1
          fi
          
          echo "üîç Debug - ECR_REPOSITORY_URL: ${ECR_REPOSITORY_URL}"
          echo "üîç Debug - IMAGE_TAG: ${IMAGE_TAG}"
          echo "üîç Debug - ECR_IMAGE_URI: ${ECR_IMAGE_URI}"
          
          echo "ECR_REGISTRY=${ECR_REGISTRY}" >> "$GITHUB_ENV"
          echo "ECR_REPOSITORY_URL=${ECR_REPOSITORY_URL}" >> "$GITHUB_ENV"
          echo "IMAGE_TAG=${IMAGE_TAG}" >> "$GITHUB_ENV"
          echo "ECR_IMAGE_URI=${ECR_IMAGE_URI}" >> "$GITHUB_ENV"
          
          echo "ecr_repository_url=${ECR_REPOSITORY_URL}" >> "$GITHUB_OUTPUT"
          echo "image_tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"
          echo "ecr_image_uri=${ECR_IMAGE_URI}" >> "$GITHUB_OUTPUT"
          
          echo "‚úÖ Output definido: ecr_image_uri=${ECR_IMAGE_URI}"

      - name: Build Docker image
        id: build
        run: |
          docker build -t ${{ env.ECR_IMAGE_URI }} .
          echo "‚úÖ Imagem buildada: ${{ env.ECR_IMAGE_URI }}"

      - name: Tag image as latest
        run: |
          docker tag ${{ env.ECR_IMAGE_URI }} ${{ env.ECR_REPOSITORY_URL }}:latest

      - name: Push image to ECR
        run: |
          docker push ${{ env.ECR_IMAGE_URI }}
          docker push ${{ env.ECR_REPOSITORY_URL }}:latest

      - name: Verify job output
        run: |
          echo "üîç Verificando output do job..."
          echo "Output do step vars: ${{ steps.vars.outputs.ecr_image_uri }}"
          echo "Output do job ser√°: ${{ steps.vars.outputs.ecr_image_uri }}"
          if [ -z "${{ steps.vars.outputs.ecr_image_uri }}" ]; then
            echo "‚ö†Ô∏è Aviso: Output do step vars est√° vazio!"
            echo "Vari√°vel de ambiente ECR_IMAGE_URI: ${ECR_IMAGE_URI}"
          else
            echo "‚úÖ Output do job est√° definido corretamente"
          fi

  terraform-apply:
    name: Deploy Lambda via Terraform
    needs: build-and-push
    runs-on: ubuntu-latest
    strategy:
      matrix:
        lambda_mode: [Customer, Admin, Migrator]
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3
        with:
          terraform_version: 1.6.0

      - name: Configurar vari√°veis por modo Lambda
        id: lambda-config
        env:
          LAMBDA_MODE: ${{ matrix.lambda_mode }}
          # Permitir override via secrets se necess√°rio
          LAMBDA_FUNCTION_NAME_CUSTOMER: ${{ secrets.LAMBDA_FUNCTION_NAME_CUSTOMER }}
          LAMBDA_FUNCTION_NAME_ADMIN: ${{ secrets.LAMBDA_FUNCTION_NAME_ADMIN }}
          LAMBDA_FUNCTION_NAME_MIGRATOR: ${{ secrets.LAMBDA_FUNCTION_NAME_MIGRATOR }}
          # Usar uma √∫nica role ARN para todos os lambdas
          LAMBDA_ROLE_ARN: ${{ secrets.LAMBDA_ROLE_ARN }}
        run: |
          # Manter o valor original do matrix (Customer, Admin, Migrator) para o Terraform
          LAMBDA_MODE="${{ matrix.lambda_mode }}"
          LAMBDA_MODE_UPPER=$(echo "${LAMBDA_MODE}" | tr '[:lower:]' '[:upper:]')
          
          # Valores padr√£o baseados no modo
          case "${LAMBDA_MODE_UPPER}" in
            CUSTOMER)
              DEFAULT_FUNCTION_NAME="fiap-fase4-infra-auth-lambda"
              ;;
            ADMIN)
              DEFAULT_FUNCTION_NAME="fiap-fase4-infra-auth-admin-lambda"
              ;;
            MIGRATOR)
              DEFAULT_FUNCTION_NAME="fiap-fase4-infra-auth-migrator-lambda"
              ;;
            *)
              echo "‚ùå Erro: Modo Lambda inv√°lido: ${LAMBDA_MODE}"
              exit 1
              ;;
          esac
          
          # Construir nome da vari√°vel de override baseado no modo
          FUNCTION_NAME_VAR="LAMBDA_FUNCTION_NAME_${LAMBDA_MODE_UPPER}"
          
          # Obter valor da vari√°vel de ambiente (override) ou usar padr√£o
          LAMBDA_FUNCTION_NAME=$(eval echo \$${FUNCTION_NAME_VAR})
          if [ -z "${LAMBDA_FUNCTION_NAME}" ]; then
            LAMBDA_FUNCTION_NAME="${DEFAULT_FUNCTION_NAME}"
            echo "‚ÑπÔ∏è Usando nome padr√£o para ${LAMBDA_MODE}: ${LAMBDA_FUNCTION_NAME}"
          else
            echo "‚ÑπÔ∏è Usando nome customizado para ${LAMBDA_MODE}: ${LAMBDA_FUNCTION_NAME}"
          fi
          
          # Usar a mesma role ARN para todos (pode ser definida via secret ou ser√° validada depois)
          if [ -z "${LAMBDA_ROLE_ARN}" ]; then
            echo "‚ö†Ô∏è Aviso: LAMBDA_ROLE_ARN n√£o est√° configurado via secret"
            echo "   O Terraform pode usar um valor padr√£o ou falhar se for obrigat√≥rio"
          fi
          
          echo "üîç Modo Lambda: ${LAMBDA_MODE}"
          echo "üîç Lambda Function Name: ${LAMBDA_FUNCTION_NAME}"
          echo "üîç Lambda Role ARN: ${LAMBDA_ROLE_ARN:-n√£o configurado}"
          
          # Passar o valor original (Customer, Admin, Migrator) para o Terraform
          echo "lambda_mode=${LAMBDA_MODE}" >> "$GITHUB_OUTPUT"
          echo "lambda_function_name=${LAMBDA_FUNCTION_NAME}" >> "$GITHUB_OUTPUT"
          echo "lambda_role_arn=${LAMBDA_ROLE_ARN}" >> "$GITHUB_OUTPUT"

      - name: Terraform Init
        working-directory: ./terraform
        env:
          TF_BACKEND_BUCKET: ${{ secrets.TF_BACKEND_BUCKET }}
          TF_BACKEND_KEY: ${{ secrets.TF_BACKEND_KEY }}
          TF_BACKEND_REGION: ${{ secrets.AWS_REGION }}
        run: |
          if [ -z "$TF_BACKEND_BUCKET" ] || [ -z "$TF_BACKEND_KEY" ]; then
            echo "‚ùå Erro: Secrets TF_BACKEND_BUCKET e TF_BACKEND_KEY devem estar configurados"
            echo "Configure os secrets no GitHub: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "TF_BACKEND_BUCKET est√° vazio: $([ -z "$TF_BACKEND_BUCKET" ] && echo 'SIM' || echo 'N√ÉO')"
            echo "TF_BACKEND_KEY est√° vazio: $([ -z "$TF_BACKEND_KEY" ] && echo 'SIM' || echo 'N√ÉO')"
            exit 1
          fi
          echo "üîß Configurando backend S3..."
          echo "Bucket: ${TF_BACKEND_BUCKET}"
          echo "Key: ${TF_BACKEND_KEY}"
          echo "Region: ${TF_BACKEND_REGION}"
          terraform init \
            -input=false \
            -reconfigure \
            -backend-config="bucket=${TF_BACKEND_BUCKET}" \
            -backend-config="key=${TF_BACKEND_KEY}" \
            -backend-config="region=${TF_BACKEND_REGION}"

      - name: Debug - Verificar e configurar ECR_IMAGE_URI
        id: setup-ecr-uri
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          ECR_REPOSITORY_NAME: ${{ secrets.ECR_REPOSITORY_NAME }}
        run: |
          echo "üîç Debug - Outputs do job build-and-push:"
          ECR_URI="${{ needs.build-and-push.outputs.ecr_image_uri }}"
          echo "ecr_image_uri (direto): ${ECR_URI}"
          echo ""
          echo "üîç Todos os outputs dispon√≠veis (JSON):"
          echo "${{ toJSON(needs.build-and-push.outputs) }}"
          echo ""
          
          # Valida se a URI est√° completa (deve come√ßar com n√∫mero do account)
          if [ -n "${ECR_URI}" ] && [[ "${ECR_URI}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚úÖ ECR_URI v√°lida encontrada: ${ECR_URI}"
            echo "ECR_IMAGE_URI=${ECR_URI}" >> "$GITHUB_ENV"
            echo "ecr_image_uri=${ECR_URI}" >> "$GITHUB_OUTPUT"
          else
            echo "‚ö†Ô∏è ECR_URI est√° vazia, inv√°lida ou incompleta do output do job!"
            echo "URI recebida: '${ECR_URI}'"
            echo "Tentando construir manualmente..."
            # Constr√≥i manualmente como fallback
            if [ -z "${AWS_ACCOUNT_ID}" ]; then
              echo "‚ùå Erro: AWS_ACCOUNT_ID n√£o est√° dispon√≠vel!"
              exit 1
            fi
            if [ -z "${ECR_REPOSITORY_NAME}" ]; then
              echo "‚ùå Erro: ECR_REPOSITORY_NAME n√£o est√° dispon√≠vel!"
              exit 1
            fi
            IMAGE_TAG="sha-${GITHUB_SHA::7}"
            ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${IMAGE_TAG}"
            echo "ECR_IMAGE_URI=${ECR_URI}" >> "$GITHUB_ENV"
            echo "ecr_image_uri=${ECR_URI}" >> "$GITHUB_OUTPUT"
            echo "‚úÖ ECR_URI constru√≠do manualmente: ${ECR_URI}"
          fi
          
          # Valida√ß√£o final antes de continuar
          FINAL_URI="${ECR_IMAGE_URI:-${ECR_URI}}"
          if [[ ! "${FINAL_URI}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚ùå Erro cr√≠tico: ECR_IMAGE_URI final est√° inv√°lida: ${FINAL_URI}"
            echo "Formato esperado: <account-id>.dkr.ecr.<region>.amazonaws.com/<repo>:<tag>"
            exit 1
          fi
          echo "‚úÖ Valida√ß√£o final: ECR_IMAGE_URI=${FINAL_URI}"

      - name: Verificar e importar Lambda existente (se necess√°rio)
        working-directory: ./terraform
        id: import-lambda
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.lambda-config.outputs.lambda_function_name }}
          LAMBDA_ROLE_ARN: ${{ steps.lambda-config.outputs.lambda_role_arn }}
          LAMBDA_MODE: ${{ steps.lambda-config.outputs.lambda_mode }}
          ECR_IMAGE_URI: ${{ env.ECR_IMAGE_URI }}
        run: |
          echo "üîç Verificando se Lambda '${LAMBDA_FUNCTION_NAME}' (modo: ${LAMBDA_MODE}) existe na AWS..."
          
          # Verifica se o Lambda existe na AWS
          LAMBDA_EXISTS=false
          if aws lambda get-function \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --region "${AWS_REGION}" > /dev/null 2>&1; then
            LAMBDA_EXISTS=true
            echo "‚úÖ Lambda encontrado na AWS: ${LAMBDA_FUNCTION_NAME}"
          else
            echo "‚ÑπÔ∏è Lambda n√£o existe na AWS, ser√° criado pelo Terraform"
            echo "lambda_imported=false" >> "$GITHUB_OUTPUT"
            echo "lambda_exists=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          # Obt√©m informa√ß√µes completas do Lambda na AWS
          echo ""
          echo "üîç Informa√ß√µes do Lambda na AWS:"
          LAMBDA_FULL_INFO=$(aws lambda get-function \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --region "${AWS_REGION}" \
            --output json 2>/dev/null)
          
          if [ -n "${LAMBDA_FULL_INFO}" ]; then
            # Extrai informa√ß√µes principais
            LAMBDA_INFO=$(echo "${LAMBDA_FULL_INFO}" | jq -r '.Configuration | [.FunctionName, .FunctionArn, .Role, .LastModified, .PackageType, .ImageUri, .State] | @json')
            echo "${LAMBDA_INFO}" | jq -r '.[]' | paste - - - - - - - | column -t -s $'\t' || echo "${LAMBDA_INFO}"
            
            CURRENT_IMAGE_URI=$(echo "${LAMBDA_FULL_INFO}" | jq -r '.Configuration.ImageUri // empty')
            CURRENT_ROLE=$(echo "${LAMBDA_FULL_INFO}" | jq -r '.Configuration.Role // empty')
            CURRENT_TAGS=$(echo "${LAMBDA_FULL_INFO}" | jq -r '.Tags // {}')
            
            echo ""
            echo "  - Image URI atual: ${CURRENT_IMAGE_URI}"
            echo "  - Role atual: ${CURRENT_ROLE}"
            echo "  - Tags:"
            echo "${CURRENT_TAGS}" | jq -r 'to_entries[] | "    - \(.key): \(.value)"' || echo "    (sem tags ou erro ao ler)"
            
            # Verifica se h√° tags indicando gerenciamento por outro Terraform
            MANAGED_BY=$(echo "${CURRENT_TAGS}" | jq -r '.ManagedBy // empty')
            if [ -n "${MANAGED_BY}" ] && [ "${MANAGED_BY}" != "Terraform" ]; then
              echo ""
              echo "‚ö†Ô∏è ATEN√á√ÉO: Lambda pode estar sendo gerenciado por outro Terraform!"
              echo "   Tag ManagedBy: ${MANAGED_BY}"
              echo "   Este Terraform gerenciar√° apenas a image_uri"
            fi
          fi
          
          # Verifica se o Lambda j√° est√° no estado do Terraform
          echo ""
          echo "üîç Verificando estado do Terraform..."
          LAMBDA_IN_STATE=false
          if terraform state show aws_lambda_function.lambda > /dev/null 2>&1; then
            LAMBDA_IN_STATE=true
            echo "‚úÖ Lambda j√° est√° no estado do Terraform"
            
            # Mostra diferen√ßas
            echo ""
            echo "üìä Estado atual no Terraform:"
            terraform state show aws_lambda_function.lambda | grep -E "(function_name|image_uri|role)" || true
          else
            echo "‚ö†Ô∏è Lambda existe na AWS mas N√ÉO est√° no estado do Terraform"
          fi
          
          # Sempre tenta importar/atualizar o estado para garantir sincroniza√ß√£o
          # Se j√° estiver no estado, o import vai atualizar com os valores atuais da AWS
          echo ""
          echo "üì• Importando/atualizando Lambda no estado do Terraform..."
          
          # Usa a URI atual do Lambda (importa o estado atual, n√£o a nova)
          IMPORT_IMAGE_URI="${CURRENT_IMAGE_URI:-${ECR_IMAGE_URI}}"
          IMPORT_ROLE="${CURRENT_ROLE:-${LAMBDA_ROLE_ARN}}"
          
          echo "  - Usando image_uri atual: ${IMPORT_IMAGE_URI}"
          echo "  - Usando role atual: ${IMPORT_ROLE}"
          
          # Importa o Lambda para o estado do Terraform
          # Se j√° estiver no estado, o import vai atualizar
          echo "üîç Executando terraform import..."
          echo "  - Function Name: ${LAMBDA_FUNCTION_NAME}"
          echo "  - Region: ${AWS_REGION}"
          echo "  - Mode: ${LAMBDA_MODE}"
          echo "  - Image URI (para import): ${IMPORT_IMAGE_URI}"
          echo "  - Role ARN (para import): ${IMPORT_ROLE}"
          
          IMPORT_OUTPUT=$(terraform import \
            -var="aws_region=${AWS_REGION}" \
            -var="lambda_function_name=${LAMBDA_FUNCTION_NAME}" \
            -var="lambda_mode=${LAMBDA_MODE}" \
            -var="ecr_image_uri=${IMPORT_IMAGE_URI}" \
            -var="lambda_role_arn=${IMPORT_ROLE}" \
            -var="cognito_user_pool_id=dummy" \
            -var="cognito_region=${AWS_REGION}" \
            -var="cognito_client_id=dummy" \
            -var="rds_connection_string=dummy" \
            -var="jwt_secret=dummy" \
            -var="jwt_issuer=dummy" \
            -var="jwt_audience=dummy" \
            aws_lambda_function.lambda "${LAMBDA_FUNCTION_NAME}" 2>&1)
          IMPORT_EXIT_CODE=$?
          
          echo "üîç Exit code do import: ${IMPORT_EXIT_CODE}"
          
          if [ ${IMPORT_EXIT_CODE} -eq 0 ]; then
            echo "‚úÖ Lambda importado/atualizado com sucesso no estado do Terraform"
            echo "lambda_imported=true" >> "$GITHUB_OUTPUT"
          else
            # Se o erro for porque j√° est√° no estado, verifica se realmente est√°
            if echo "${IMPORT_OUTPUT}" | grep -qi "already in state\|already managed"; then
              echo "‚ÑπÔ∏è Lambda j√° est√° no estado do Terraform (isso √© esperado)"
              # Verifica novamente para garantir
              if terraform state show aws_lambda_function.lambda > /dev/null 2>&1; then
                echo "‚úÖ Confirmado: Lambda est√° no estado do Terraform"
                echo "lambda_imported=true" >> "$GITHUB_OUTPUT"
              else
                echo "‚ö†Ô∏è Aviso: Lambda deveria estar no estado mas n√£o foi encontrado"
                echo "lambda_imported=false" >> "$GITHUB_OUTPUT"
              fi
            else
              echo "‚ùå Erro: Falha ao importar Lambda existente"
              echo "Output completo do import:"
              echo "${IMPORT_OUTPUT}"
              echo ""
              echo "üí° Tentando abordagem alternativa: atualizar imagem diretamente via AWS CLI"
              echo ""
              
              # Tenta atualizar a imagem diretamente via AWS CLI como fallback
              echo "üîÑ Atualizando imagem do Lambda via AWS CLI..."
              UPDATE_OUTPUT=$(aws lambda update-function-code \
                --function-name "${LAMBDA_FUNCTION_NAME}" \
                --image-uri "${ECR_IMAGE_URI}" \
                --region "${AWS_REGION}" \
                2>&1)
              UPDATE_EXIT_CODE=$?
              
              if [ ${UPDATE_EXIT_CODE} -eq 0 ]; then
                echo "‚úÖ Imagem atualizada com sucesso via AWS CLI"
                echo "‚ö†Ô∏è Lambda n√£o foi importado para o Terraform, mas a imagem foi atualizada"
                echo "   Para pr√≥ximos deploys, ser√° necess√°rio importar manualmente ou corrigir o import"
                echo "lambda_imported=false" >> "$GITHUB_OUTPUT"
                echo "image_updated_via_cli=true" >> "$GITHUB_OUTPUT"
              else
                echo "‚ùå Falha ao atualizar imagem via AWS CLI tamb√©m"
                echo "Output do update:"
                echo "${UPDATE_OUTPUT}"
                echo ""
                echo "üìã Poss√≠veis causas:"
                echo "   1. Permiss√µes IAM insuficientes"
                echo "   2. Imagem n√£o existe no ECR"
                echo "   3. Lambda n√£o existe ou est√° em estado inv√°lido"
                echo ""
                echo "‚ùå Falhando o workflow - n√£o foi poss√≠vel atualizar o Lambda"
                exit 1
              fi
            fi
          fi
          echo "lambda_exists=true" >> "$GITHUB_OUTPUT"
          
          # Verifica√ß√£o final: garantir que o Lambda est√° no estado antes de continuar
          echo ""
          echo "üîç Verifica√ß√£o final do estado do Terraform..."
          if terraform state show aws_lambda_function.lambda > /dev/null 2>&1; then
            echo "‚úÖ Lambda confirmado no estado do Terraform - pronto para atualizar image_uri"
          else
            echo "‚ö†Ô∏è ATEN√á√ÉO: Lambda N√ÉO est√° no estado do Terraform"
            echo "   O Terraform pode tentar criar o Lambda, o que causar√° erro"
            echo "   Continuando, mas pode falhar no apply..."
          fi
          
          echo ""
          echo "üîç Estado atual do Terraform:"
          terraform state list 2>/dev/null | head -20 || echo "Estado vazio ou n√£o inicializado"

      - name: Terraform Plan
        if: steps.import-lambda.outputs.image_updated_via_cli != 'true'
        working-directory: ./terraform
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.lambda-config.outputs.lambda_function_name }}
          LAMBDA_ROLE_ARN: ${{ steps.lambda-config.outputs.lambda_role_arn }}
          LAMBDA_MODE: ${{ steps.lambda-config.outputs.lambda_mode }}
          ECR_IMAGE_URI: ${{ env.ECR_IMAGE_URI }}
          COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
          COGNITO_REGION: ${{ secrets.COGNITO_REGION }}
          COGNITO_CLIENT_ID: ${{ secrets.COGNITO_CLIENT_ID }}
          RDS_CONNECTION_STRING: ${{ secrets.RDS_CONNECTION_STRING }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          JWT_EXPIRATION_HOURS: ${{ secrets.JWT_EXPIRATION_HOURS }}
        run: |
          echo "üîç Verificando vari√°veis antes do plan..."
          echo "  - AWS_REGION: ${AWS_REGION}"
          echo "  - LAMBDA_FUNCTION_NAME: ${LAMBDA_FUNCTION_NAME}"
          echo "  - LAMBDA_ROLE_ARN: ${LAMBDA_ROLE_ARN}"
          echo "  - ECR_IMAGE_URI: ${ECR_IMAGE_URI}"
          echo "  - COGNITO_USER_POOL_ID: ${COGNITO_USER_POOL_ID:+***configurado***}"
          echo "  - COGNITO_REGION: ${COGNITO_REGION}"
          echo "  - COGNITO_CLIENT_ID: ${COGNITO_CLIENT_ID:+***configurado***}"
          echo "  - RDS_CONNECTION_STRING: ${RDS_CONNECTION_STRING:+***configurado***}"
          echo "  - JWT_SECRET: ${JWT_SECRET:+***configurado***}"
          echo "  - JWT_ISSUER: ${JWT_ISSUER}"
          echo "  - JWT_AUDIENCE: ${JWT_AUDIENCE}"
          echo "  - JWT_EXPIRATION_HOURS: ${JWT_EXPIRATION_HOURS:-24 (default)}"
          echo ""
          
          # Valida√ß√µes obrigat√≥rias
          if [ -z "${ECR_IMAGE_URI}" ]; then
            echo "‚ùå Erro: ECR_IMAGE_URI est√° vazio!"
            exit 1
          fi
          
          if [ -z "${COGNITO_USER_POOL_ID}" ]; then
            echo "‚ùå Erro: COGNITO_USER_POOL_ID √© obrigat√≥rio!"
            exit 1
          fi
          
          if [ -z "${COGNITO_REGION}" ]; then
            echo "‚ùå Erro: COGNITO_REGION √© obrigat√≥rio!"
            exit 1
          fi
          
          if [ -z "${COGNITO_CLIENT_ID}" ]; then
            echo "‚ùå Erro: COGNITO_CLIENT_ID √© obrigat√≥rio!"
            exit 1
          fi
          
          if [ -z "${RDS_CONNECTION_STRING}" ]; then
            echo "‚ùå Erro: RDS_CONNECTION_STRING √© obrigat√≥rio!"
            exit 1
          fi
          
          if [ -z "${JWT_SECRET}" ]; then
            echo "‚ùå Erro: JWT_SECRET √© obrigat√≥rio!"
            exit 1
          fi
          
          if [ -z "${JWT_ISSUER}" ]; then
            echo "‚ùå Erro: JWT_ISSUER √© obrigat√≥rio!"
            exit 1
          fi
          
          if [ -z "${JWT_AUDIENCE}" ]; then
            echo "‚ùå Erro: JWT_AUDIENCE √© obrigat√≥rio!"
            exit 1
          fi
          
          # Valida formato da URI
          if [[ ! "${ECR_IMAGE_URI}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚ùå Erro: ECR_IMAGE_URI est√° em formato inv√°lido: ${ECR_IMAGE_URI}"
            exit 1
          fi
          
          # Valida JWT_SECRET tem pelo menos 32 caracteres
          if [ ${#JWT_SECRET} -lt 32 ]; then
            echo "‚ö†Ô∏è Aviso: JWT_SECRET deve ter no m√≠nimo 32 caracteres (atual: ${#JWT_SECRET})"
          fi
          
          echo "‚úÖ Todas as vari√°veis est√£o v√°lidas"
          echo ""
          echo "üìã Executando terraform plan..."
          
          # Constr√≥i comando terraform plan com vari√°veis obrigat√≥rias
          TF_PLAN_ARGS=(
            -var="aws_region=${AWS_REGION}"
            -var="lambda_function_name=${LAMBDA_FUNCTION_NAME}"
            -var="lambda_mode=${LAMBDA_MODE}"
            -var="ecr_image_uri=${ECR_IMAGE_URI}"
            -var="lambda_role_arn=${LAMBDA_ROLE_ARN}"
            -var="cognito_user_pool_id=${COGNITO_USER_POOL_ID}"
            -var="cognito_region=${COGNITO_REGION}"
            -var="cognito_client_id=${COGNITO_CLIENT_ID}"
            -var="rds_connection_string=${RDS_CONNECTION_STRING}"
            -var="jwt_secret=${JWT_SECRET}"
            -var="jwt_issuer=${JWT_ISSUER}"
            -var="jwt_audience=${JWT_AUDIENCE}"
          )
          
          # Adiciona vari√°veis opcionais se fornecidas
          if [ -n "${JWT_EXPIRATION_HOURS}" ]; then
            TF_PLAN_ARGS+=(-var="jwt_expiration_hours=${JWT_EXPIRATION_HOURS}")
          fi
          
          terraform plan "${TF_PLAN_ARGS[@]}" -out=tfplan
          
          echo ""
          echo "üìä Resumo do plano:"
          terraform show -json tfplan | jq -r '.resource_changes[] | select(.type == "aws_lambda_function") | "  - \(.type).\(.name): \(.change.actions[])"' 2>/dev/null || echo "  (jq n√£o dispon√≠vel, pulando resumo)"

      - name: Verificar se imagem existe no ECR
        if: steps.import-lambda.outputs.image_updated_via_cli != 'true'
        env:
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          ECR_REPOSITORY_NAME: ${{ secrets.ECR_REPOSITORY_NAME }}
        run: |
          echo "üîç Verificando se a imagem existe no ECR..."
          IMAGE_TAG="sha-${GITHUB_SHA::7}"
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${IMAGE_TAG}"
          echo "Verificando imagem: ${IMAGE_URI}"
          
          # Verifica se a imagem existe no ECR
          if aws ecr describe-images \
            --repository-name "${ECR_REPOSITORY_NAME}" \
            --image-ids imageTag="${IMAGE_TAG}" \
            --region "${AWS_REGION}" > /dev/null 2>&1; then
            echo "‚úÖ Imagem encontrada no ECR: ${IMAGE_URI}"
          else
            echo "‚ùå Erro: Imagem n√£o encontrada no ECR: ${IMAGE_URI}"
            echo "Verificando tags dispon√≠veis..."
            aws ecr describe-images \
              --repository-name "${ECR_REPOSITORY_NAME}" \
              --region "${AWS_REGION}" \
              --query 'imageDetails[*].imageTags' \
              --output table || true
            exit 1
          fi

      - name: Terraform Apply
        if: steps.import-lambda.outputs.image_updated_via_cli != 'true'
        working-directory: ./terraform
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.lambda-config.outputs.lambda_function_name }}
          LAMBDA_ROLE_ARN: ${{ steps.lambda-config.outputs.lambda_role_arn }}
          LAMBDA_MODE: ${{ steps.lambda-config.outputs.lambda_mode }}
          ECR_IMAGE_URI: ${{ env.ECR_IMAGE_URI }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          ECR_REPOSITORY_NAME: ${{ secrets.ECR_REPOSITORY_NAME }}
          COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
          COGNITO_REGION: ${{ secrets.COGNITO_REGION }}
          COGNITO_CLIENT_ID: ${{ secrets.COGNITO_CLIENT_ID }}
          RDS_CONNECTION_STRING: ${{ secrets.RDS_CONNECTION_STRING }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          JWT_EXPIRATION_HOURS: ${{ secrets.JWT_EXPIRATION_HOURS }}
        run: |
          echo "üîç Verificando vari√°veis antes do apply..."
          echo "ECR_IMAGE_URI recebida: '${ECR_IMAGE_URI}'"
          
          # Se a URI estiver vazia ou incompleta, reconstr√≥i
          if [ -z "${ECR_IMAGE_URI}" ] || [[ ! "${ECR_IMAGE_URI}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚ö†Ô∏è ECR_IMAGE_URI est√° vazia ou incompleta, reconstruindo..."
            if [ -z "${AWS_ACCOUNT_ID}" ] || [ -z "${ECR_REPOSITORY_NAME}" ]; then
              echo "‚ùå Erro: AWS_ACCOUNT_ID ou ECR_REPOSITORY_NAME n√£o est√£o dispon√≠veis para reconstruir URI!"
              exit 1
            fi
            IMAGE_TAG="sha-${GITHUB_SHA::7}"
            ECR_IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY_NAME}:${IMAGE_TAG}"
            echo "‚úÖ ECR_IMAGE_URI reconstru√≠da: ${ECR_IMAGE_URI}"
          fi
          
          # Valida√ß√£o final obrigat√≥ria
          if [[ ! "${ECR_IMAGE_URI}" =~ ^[0-9]+\.dkr\.ecr\..+ ]]; then
            echo "‚ùå Erro cr√≠tico: ECR_IMAGE_URI final est√° inv√°lida: ${ECR_IMAGE_URI}"
            echo "Formato esperado: <account-id>.dkr.ecr.<region>.amazonaws.com/<repo>:<tag>"
            exit 1
          fi
          
          echo "‚úÖ ECR_IMAGE_URI v√°lida e completa: ${ECR_IMAGE_URI}"
          echo ""
          echo "üîç Vari√°veis que ser√£o passadas para Terraform:"
          echo "  - aws_region: ${AWS_REGION}"
          echo "  - lambda_function_name: ${LAMBDA_FUNCTION_NAME}"
          echo "  - ecr_image_uri: ${ECR_IMAGE_URI}"
          echo "  - lambda_role_arn: ${LAMBDA_ROLE_ARN}"
          echo "  - cognito_user_pool_id: ${COGNITO_USER_POOL_ID:+***configurado***}"
          echo "  - cognito_region: ${COGNITO_REGION}"
          echo "  - cognito_client_id: ${COGNITO_CLIENT_ID:+***configurado***}"
          echo "  - rds_connection_string: ${RDS_CONNECTION_STRING:+***configurado***}"
          echo "  - jwt_secret: ${JWT_SECRET:+***configurado***}"
          echo "  - jwt_issuer: ${JWT_ISSUER}"
          echo "  - jwt_audience: ${JWT_AUDIENCE}"
          echo "  - jwt_expiration_hours: ${JWT_EXPIRATION_HOURS:-24 (default)}"
          echo ""
          
          # Constr√≥i comando terraform apply com vari√°veis obrigat√≥rias
          TF_APPLY_ARGS=(
            -var="aws_region=${AWS_REGION}"
            -var="lambda_function_name=${LAMBDA_FUNCTION_NAME}"
            -var="lambda_mode=${LAMBDA_MODE}"
            -var="ecr_image_uri=${ECR_IMAGE_URI}"
            -var="lambda_role_arn=${LAMBDA_ROLE_ARN}"
            -var="cognito_user_pool_id=${COGNITO_USER_POOL_ID}"
            -var="cognito_region=${COGNITO_REGION}"
            -var="cognito_client_id=${COGNITO_CLIENT_ID}"
            -var="rds_connection_string=${RDS_CONNECTION_STRING}"
            -var="jwt_secret=${JWT_SECRET}"
            -var="jwt_issuer=${JWT_ISSUER}"
            -var="jwt_audience=${JWT_AUDIENCE}"
          )
          
          # Adiciona vari√°veis opcionais se fornecidas
          if [ -n "${JWT_EXPIRATION_HOURS}" ]; then
            TF_APPLY_ARGS+=(-var="jwt_expiration_hours=${JWT_EXPIRATION_HOURS}")
          fi
          
          # Verifica se h√° um plano salvo e aplica, sen√£o aplica diretamente
          if [ -f "tfplan" ]; then
            echo "üìã Aplicando plano salvo (tfplan)..."
            terraform apply tfplan
          else
            echo "üìã Aplicando mudan√ßas diretamente..."
            terraform apply -auto-approve "${TF_APPLY_ARGS[@]}"
          fi
          
          echo ""
          echo "üìä Outputs do Terraform ap√≥s apply:"
          terraform output -json 2>/dev/null | jq -r 'to_entries[] | "  - \(.key): \(.value.value)"' || terraform output

      - name: Debug - Informa√ß√µes finais do Lambda
        working-directory: ./terraform
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.lambda-config.outputs.lambda_function_name }}
        run: |
          echo "üîç Informa√ß√µes finais do Lambda ap√≥s deploy:"
          echo ""
          echo "üìã Estado do Terraform:"
          terraform state show aws_lambda_function.lambda 2>/dev/null | grep -E "(function_name|arn|image_uri|last_modified)" || echo "  (Lambda n√£o encontrado no estado)"
          echo ""
          echo "üìã Informa√ß√µes na AWS:"
          aws lambda get-function \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --region "${AWS_REGION}" \
            --query 'Configuration.[FunctionName,FunctionArn,ImageUri,LastModified,State,StateReason]' \
            --output table 2>/dev/null || echo "  (Erro ao consultar Lambda na AWS)"
