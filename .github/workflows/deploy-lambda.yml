name: Deploy Lambda Functions to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch: # Permite execu√ß√£o manual

# IMPORTANTE: Garante que apenas uma execu√ß√£o ocorra por vez
# Usa um grupo fixo para que todas as execu√ß√µes do workflow compartilhem o mesmo grupo
# Quando uma PR √© aceita e m√∫ltiplos eventos push s√£o disparados simultaneamente,
# apenas a execu√ß√£o mais recente rodar√° e as outras ser√£o canceladas imediatamente
concurrency:
  group: deploy-lambda-main
  cancel-in-progress: true

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID || '058264347413' }}

jobs:
  build-and-push-images:
    name: Build and Push Docker Images to ECR
    needs: [create-ecr-repository]
    runs-on: ubuntu-latest
    
    outputs:
      lambda_auth_customer_image_uri: ${{ steps.meta-customer.outputs.image }}
      lambda_auth_admin_image_uri: ${{ steps.meta-admin.outputs.image }}
      lambda_auth_migrator_image_uri: ${{ steps.meta-migrator.outputs.image }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@062b18b96a7aff071d4dc91bc00c4c1a7945b076 # v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3

      - name: Build and push auth-customer-lambda image
        id: build-customer
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
        with:
          context: .
          file: ./Dockerfile.auth-customer-lambda
          push: true
          tags: |
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-customer-lambda-${{ github.sha }}
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-customer-lambda-latest
          cache-from: type=registry,ref=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-customer-lambda-buildcache
          cache-to: type=registry,ref=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-customer-lambda-buildcache,mode=max

      - name: Set auth-customer-lambda image URI
        id: meta-customer
        run: |
          echo "image=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-customer-lambda-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build and push auth-admin-lambda image
        id: build-admin
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
        with:
          context: .
          file: ./Dockerfile.auth-admin-lambda
          push: true
          tags: |
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-admin-lambda-${{ github.sha }}
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-admin-lambda-latest
          cache-from: type=registry,ref=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-admin-lambda-buildcache
          cache-to: type=registry,ref=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-admin-lambda-buildcache,mode=max

      - name: Set auth-admin-lambda image URI
        id: meta-admin
        run: |
          echo "image=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-admin-lambda-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Build and push auth-migrator-lambda image
        id: build-migrator
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25 # v5
        with:
          context: .
          file: ./Dockerfile.auth-migrator-lambda
          push: true
          tags: |
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-migrator-lambda-${{ github.sha }}
            ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-migrator-lambda-latest
          cache-from: type=registry,ref=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-migrator-lambda-buildcache
          cache-to: type=registry,ref=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-migrator-lambda-buildcache,mode=max

      - name: Set auth-migrator-lambda image URI
        id: meta-migrator
        run: |
          echo "image=${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/fiap-fase4-auth-lambda:auth-migrator-lambda-${{ github.sha }}" >> $GITHUB_OUTPUT

  build-and-package:
    name: Build and Package .NET Lambda Functions
    runs-on: ubuntu-latest
    
    outputs:
      lambda_auth_customer_zip: ${{ steps.package.outputs.lambda_auth_customer_zip }}
      lambda_auth_admin_zip: ${{ steps.package.outputs.lambda_auth_admin_zip }}
      lambda_auth_migrator_zip: ${{ steps.package.outputs.lambda_auth_migrator_zip }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Setup .NET
        uses: actions/setup-dotnet@67a3573c9a986a3f9c594539f4ab511d57bb3ce9 # v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build Lambda (auth-customer-lambda)
        run: |
          dotnet publish src/InterfacesExternas/FastFood.Auth.Lambda.Customer/FastFood.Auth.Lambda.Customer.csproj \
            -c Release \
            -o publish/auth-customer-lambda \
            --self-contained true \
            -r linux-x64

      - name: Build Lambda (auth-admin-lambda)
        run: |
          dotnet publish src/InterfacesExternas/FastFood.Auth.Lambda.Admin/FastFood.Auth.Lambda.Admin.csproj \
            -c Release \
            -o publish/auth-admin-lambda \
            --self-contained true \
            -r linux-x64

      - name: Build Migrator Lambda (auth-migrator-lambda)
        run: |
          dotnet publish src/InterfacesExternas/FastFood.Auth.Migrator/FastFood.Auth.Migrator.csproj \
            -c Release \
            -o publish/auth-migrator-lambda \
            --self-contained true \
            -r linux-x64

      - name: Create bootstrap script for auth-customer-lambda
        run: |
          cat > publish/auth-customer-lambda/bootstrap << 'EOF'
          #!/bin/sh
          set -euo pipefail
          cd "$(dirname "$0")"
          exec ./FastFood.Auth.Lambda.Customer
          EOF
          chmod +x publish/auth-customer-lambda/bootstrap

      - name: Create bootstrap script for auth-admin-lambda
        run: |
          cat > publish/auth-admin-lambda/bootstrap << 'EOF'
          #!/bin/sh
          set -euo pipefail
          cd "$(dirname "$0")"
          exec ./FastFood.Auth.Lambda.Admin
          EOF
          chmod +x publish/auth-admin-lambda/bootstrap

      - name: Create bootstrap script for auth-migrator-lambda
        run: |
          cat > publish/auth-migrator-lambda/bootstrap << 'EOF'
          #!/bin/sh
          set -euo pipefail
          cd "$(dirname "$0")"
          exec ./FastFood.Auth.Migrator
          EOF
          chmod +x publish/auth-migrator-lambda/bootstrap

      - name: Package Lambda functions
        id: package
        run: |
          cd publish/auth-customer-lambda
          zip -r ../../lambda-auth-customer.zip . -q
          echo "lambda_auth_customer_zip=lambda-auth-customer.zip" >> $GITHUB_OUTPUT
          
          cd ../auth-admin-lambda
          zip -r ../../lambda-auth-admin.zip . -q
          echo "lambda_auth_admin_zip=lambda-auth-admin.zip" >> $GITHUB_OUTPUT
          
          cd ../auth-migrator-lambda
          zip -r ../../lambda-auth-migrator.zip . -q
          echo "lambda_auth_migrator_zip=lambda-auth-migrator.zip" >> $GITHUB_OUTPUT
          
          cd ../..
          ls -lh ./*.zip

      - name: Upload ZIP artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: lambda-zips
          path: |
            lambda-auth-customer.zip
            lambda-auth-admin.zip
            lambda-auth-migrator.zip
          retention-days: 1

  create-ecr-repository:
    name: Create ECR Repository
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4

      - name: Set project name
        id: project-name
        env:
          PROJECT_NAME_SECRET: ${{ secrets.PROJECT_NAME }}
        run: |
          PROJECT_NAME="${PROJECT_NAME_SECRET}"
          if [ -z "${PROJECT_NAME}" ]; then
            PROJECT_NAME="autenticacao"
          fi
          echo "project_name=${PROJECT_NAME}" >> $GITHUB_OUTPUT
          echo "Using project name: ${PROJECT_NAME}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Check if ECR repository exists
        id: check-ecr
        run: |
          if aws ecr describe-repositories --repository-names fiap-fase4-auth-lambda --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "‚úÖ ECR repository j√° existe"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è ECR repository n√£o existe, ser√° criado"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create ECR Repository (Terraform Apply - ECR only)
        working-directory: terraform
        env:
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_project_name: ${{ steps.project-name.outputs.project_name }}
          TF_VAR_env: ${{ secrets.ENV || 'dev' }}
          TF_VAR_lab_role: ${{ secrets.LAB_ROLE }}
        run: |
          echo "üîß Aplicando configura√ß√£o do ECR (idempotente - n√£o cria se j√° existir)..."
          terraform apply -target=aws_ecr_repository.lambda_images -target=aws_ecr_lifecycle_policy.lambda_images -auto-approve

  terraform-apply:
    name: Create/Update Lambda Infrastructure
    needs: [create-ecr-repository, build-and-push-images]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Set project name
        id: project-name
        env:
          PROJECT_NAME_SECRET: ${{ secrets.PROJECT_NAME }}
        run: |
          PROJECT_NAME="${PROJECT_NAME_SECRET}"
          if [ -z "${PROJECT_NAME}" ]; then
            PROJECT_NAME="autenticacao"
          fi
          echo "project_name=${PROJECT_NAME}" >> $GITHUB_OUTPUT
          echo "Using project name: ${PROJECT_NAME}"

      - name: Validate required secrets
        env:
          LAB_ROLE_SECRET: ${{ secrets.LAB_ROLE }}
        run: |
          if [ -z "${LAB_ROLE_SECRET}" ]; then
            echo "‚ùå ERRO: Secret LAB_ROLE n√£o est√° configurado!"
            echo "   Configure o secret LAB_ROLE no GitHub (Settings ‚Üí Secrets and variables ‚Üí Actions)"
            echo "   O valor deve ser o ARN completo da role IAM LabRole"
            echo "   Exemplo: arn:aws:iam::123456789012:role/LabRole"
            exit 1
          fi
          echo "‚úÖ LAB_ROLE configurado"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: terraform
        env:
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_project_name: ${{ steps.project-name.outputs.project_name }}
          TF_VAR_env: ${{ secrets.ENV || 'dev' }}
          TF_VAR_lab_role: ${{ secrets.LAB_ROLE }}
          TF_VAR_cognito_region: ${{ secrets.COGNITO_REGION }}
          TF_VAR_cognito_user_pool_id: ${{ secrets.COGNITO_USER_POOL_ID }}
          TF_VAR_cognito_client_id: ${{ secrets.COGNITO_CLIENT_ID }}
          TF_VAR_rds_connection_string: ${{ secrets.RDS_CONNECTION_STRING }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_jwt_issuer: ${{ secrets.JWT_ISSUER }}
          TF_VAR_jwt_audience: ${{ secrets.JWT_AUDIENCE }}
        run: |
          echo "üîç Executando terraform plan..."
          echo "  - AWS Region: ${TF_VAR_aws_region}"
          echo "  - Project Name: ${TF_VAR_project_name}"
          echo "  - Environment: ${TF_VAR_env}"
          echo "  - Lab Role: ${TF_VAR_lab_role}"
          terraform plan

      - name: Terraform Apply
        working-directory: terraform
        env:
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
          TF_VAR_project_name: ${{ steps.project-name.outputs.project_name }}
          TF_VAR_env: ${{ secrets.ENV || 'dev' }}
          TF_VAR_lab_role: ${{ secrets.LAB_ROLE }}
          TF_VAR_cognito_region: ${{ secrets.COGNITO_REGION }}
          TF_VAR_cognito_user_pool_id: ${{ secrets.COGNITO_USER_POOL_ID }}
          TF_VAR_cognito_client_id: ${{ secrets.COGNITO_CLIENT_ID }}
          TF_VAR_rds_connection_string: ${{ secrets.RDS_CONNECTION_STRING }}
          TF_VAR_jwt_secret: ${{ secrets.JWT_SECRET }}
          TF_VAR_jwt_issuer: ${{ secrets.JWT_ISSUER }}
          TF_VAR_jwt_audience: ${{ secrets.JWT_AUDIENCE }}
          TF_VAR_lambda_auth_customer_image_uri: ${{ needs.build-and-push-images.outputs.lambda_auth_customer_image_uri }}
          TF_VAR_lambda_auth_admin_image_uri: ${{ needs.build-and-push-images.outputs.lambda_auth_admin_image_uri }}
          TF_VAR_lambda_auth_migrator_image_uri: ${{ needs.build-and-push-images.outputs.lambda_auth_migrator_image_uri }}
        run: |
          echo "üöÄ Executando terraform apply..."
          echo "  - AWS Region: ${TF_VAR_aws_region}"
          echo "  - Project Name: ${TF_VAR_project_name}"
          echo "  - Environment: ${TF_VAR_env}"
          echo "  - Lab Role: ${TF_VAR_lab_role}"
          echo "  - Auth Customer Lambda Image: ${TF_VAR_lambda_auth_customer_image_uri}"
          echo "  - Auth Admin Lambda Image: ${TF_VAR_lambda_auth_admin_image_uri}"
          echo "  - Auth Migrator Lambda Image: ${TF_VAR_lambda_auth_migrator_image_uri}"
          terraform apply -auto-approve

  deploy-lambdas:
    name: Deploy Lambda Functions
    needs: [build-and-package, terraform-apply]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        lambda:
          - name: auth-customer-lambda
            zip_file: lambda-auth-customer.zip
            function_suffix: auth-customer-lambda
          - name: auth-admin-lambda
            zip_file: lambda-auth-admin.zip
            function_suffix: auth-admin-lambda
          - name: auth-migrator-lambda
            zip_file: lambda-auth-migrator.zip
            function_suffix: auth-migrator-lambda
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Set project name
        id: project-name
        env:
          PROJECT_NAME_SECRET: ${{ secrets.PROJECT_NAME }}
        run: |
          PROJECT_NAME="${PROJECT_NAME_SECRET}"
          if [ -z "${PROJECT_NAME}" ]; then
            PROJECT_NAME="autenticacao"
          fi
          echo "project_name=${PROJECT_NAME}" >> $GITHUB_OUTPUT
          echo "Using project name: ${PROJECT_NAME}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@ff717079ee2060e4bcee96c4779b553acc87447c # v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download ZIP artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4
        with:
          name: lambda-zips
          path: .

      - name: Verify Lambda exists
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.project-name.outputs.project_name }}-${{ matrix.lambda.function_suffix }}
        run: |
          echo "üîç Verificando Lambda antes de atualizar c√≥digo..."
          echo "  - Lambda Function Name: ${LAMBDA_FUNCTION_NAME}"
          
          # Verifica se o Lambda existe na AWS
          if ! aws lambda get-function \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --region "${AWS_REGION}" > /dev/null 2>&1; then
            echo "‚ùå ERRO CR√çTICO: Lambda '${LAMBDA_FUNCTION_NAME}' N√ÉO existe na AWS!"
            echo "   O Lambda deve ser criado via Terraform antes de atualizar o c√≥digo"
            echo "   Execute: terraform apply no diret√≥rio terraform/"
            exit 1
          fi
          
          # Obt√©m informa√ß√µes do Lambda
          LAMBDA_INFO=$(aws lambda get-function \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --region "${AWS_REGION}" \
            --output json 2>/dev/null)
          
          PACKAGE_TYPE=$(echo "${LAMBDA_INFO}" | jq -r '.Configuration.PackageType // "unknown"')
          
          if [ "${PACKAGE_TYPE}" != "Zip" ]; then
            echo "‚ùå ERRO CR√çTICO: Lambda n√£o √© do tipo Zip!"
            echo "   PackageType atual: ${PACKAGE_TYPE}"
            echo "   Este workflow espera que o Lambda seja do tipo 'Zip'"
            echo "   Execute: terraform apply no diret√≥rio terraform/ para corrigir"
            exit 1
          fi
          
          echo "‚úÖ Lambda encontrado e √© do tipo Zip - pronto para atualiza√ß√£o"

      - name: Update Lambda function code
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.project-name.outputs.project_name }}-${{ matrix.lambda.function_suffix }}
          ZIP_FILE: ${{ matrix.lambda.zip_file }}
        run: |
          echo "üîÑ Atualizando c√≥digo do Lambda..."
          echo "  - Lambda Function Name: ${LAMBDA_FUNCTION_NAME}"
          echo "  - ZIP File: ${ZIP_FILE}"
          
          # Verifica se o arquivo ZIP existe
          if [ ! -f "${ZIP_FILE}" ]; then
            echo "‚ùå Erro: Arquivo ZIP n√£o encontrado: ${ZIP_FILE}"
            exit 1
          fi
          
          # Atualiza o c√≥digo do Lambda usando AWS CLI
          echo ""
          echo "üìã Executando: aws lambda update-function-code --zip-file"
          echo ""
          
          UPDATE_OUTPUT=$(aws lambda update-function-code \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --zip-file "fileb://${ZIP_FILE}" \
            --region "${AWS_REGION}" \
            --output json 2>&1)
          UPDATE_EXIT_CODE=$?
          
          if [ ${UPDATE_EXIT_CODE} -eq 0 ]; then
            echo "‚úÖ C√≥digo do Lambda atualizado com sucesso!"
            echo ""
            echo "üìä Informa√ß√µes da atualiza√ß√£o:"
            echo "${UPDATE_OUTPUT}" | jq -r '. | "  - Function Name: \(.FunctionName)\n  - Last Update Status: \(.LastUpdateStatus)\n  - State: \(.State)\n  - Code Size: \(.CodeSize) bytes"' || echo "${UPDATE_OUTPUT}"
            
            # Aguarda a atualiza√ß√£o completar
            echo ""
            echo "‚è≥ Aguardando atualiza√ß√£o completar..."
            aws lambda wait function-updated \
              --function-name "${LAMBDA_FUNCTION_NAME}" \
              --region "${AWS_REGION}" || true
            
            echo "‚úÖ Lambda atualizado e pronto para uso"
          else
            echo "‚ùå Erro ao atualizar c√≥digo do Lambda (exit code: ${UPDATE_EXIT_CODE})"
            echo ""
            echo "üìã Mensagem de erro do AWS CLI:"
            echo "${UPDATE_OUTPUT}"
            exit 1
          fi

      - name: Verify Lambda update
        env:
          LAMBDA_FUNCTION_NAME: ${{ steps.project-name.outputs.project_name }}-${{ matrix.lambda.function_suffix }}
        run: |
          echo "üîç Verificando informa√ß√µes finais do Lambda ap√≥s atualiza√ß√£o..."
          echo ""
          
          LAMBDA_INFO=$(aws lambda get-function \
            --function-name "${LAMBDA_FUNCTION_NAME}" \
            --region "${AWS_REGION}" \
            --output json 2>/dev/null)
          
          if [ -n "${LAMBDA_INFO}" ]; then
            echo "üìä Informa√ß√µes do Lambda na AWS:"
            echo "${LAMBDA_INFO}" | jq -r '.Configuration | "  - Function Name: \(.FunctionName)\n  - Function ARN: \(.FunctionArn)\n  - Last Modified: \(.LastModified)\n  - State: \(.State)\n  - Package Type: \(.PackageType)\n  - Code Size: \(.CodeSize) bytes"'
            echo ""
            echo "‚úÖ Lambda atualizado com sucesso!"
          else
            echo "‚ö†Ô∏è N√£o foi poss√≠vel obter informa√ß√µes do Lambda"
          fi
